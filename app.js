// State management
let sets = [];
let currentSetId = null;
let studyCards = [];
let currentCardIndex = 0;
let currentQuestionIndex = 0; // For progressive mode
let studyResults = { correct: 0, wrong: 0, points: 0, cards: [] }; // cards array stores {card, result, question}
let progressiveMode = false;
let currentCardQuestions = []; // Questions for current card in order (sorted by order property)
let currentCardQuestionsForCardIndex = -1; // which card the cache belongs to
let shownQuestions = []; // Questions shown so far (for progressive mode - accumulates in order: Q1, Q2, Q3...)
let rounds = []; // Rounds for current set being edited
let isNewSet = true; // Track if current set is new (for free MC toggle)
const studyMultipleChoiceMode = true; // Always in MC mode for QuizCards
let selectedMCOption = null; // Track selected MC option index for current card

// Gamepad state
let gamepadState = {
    connected: false,
    gamepad: null,
    previousButtons: [],
    previousAxes: [],
    lastButtonPress: 0,
    buttonDebounceDelay: 200, // ms between button presses
    navigationIndex: 0, // For D-pad navigation
    navigationElements: []
};

// Initialize app
document.addEventListener('DOMContentLoaded', () => {
    loadBundledSets(); // Load bundled sets first
    loadSets(); // Load user sets
    setupEventListeners();
    setupGamepadSupport();
    renderSets();
    
    // Handle initial hash or hash changes
    window.addEventListener('hashchange', handleHashChange);
    
    // Check hash on initial load (after a small delay to ensure DOM is ready)
    setTimeout(() => {
        if (window.location.hash) {
            handleHashChange();
        } else {
            // No hash, ensure main view is shown
            showView('mainView', false);
        }
    }, 0);
});

// Load bundled sets from generated JavaScript file ONLY
// This file is generated by build_bundled_sets.py and contains bundledSetsData
// IMPORTANT: Bundled sets are ONLY loaded from bundled-sets.js - no JSON files are fetched
function loadBundledSets() {
    // bundledSetsData is defined in bundled-sets.js (generated by Python script)
    // If it's not defined, there are no bundled sets (no fallback to JSON files)
    if (typeof bundledSetsData !== 'undefined' && Array.isArray(bundledSetsData)) {
        // Mark all as bundled and add to sets array
        const bundledSets = bundledSetsData.map(setData => {
            setData.bundled = true;
            return setData;
        });
        sets = [...bundledSets, ...sets];
    }
    // No else clause - if bundledSetsData is missing, silently continue with empty bundled sets
    // This ensures we NEVER try to fetch JSON files from the bundled/ directory
}

// Load sets from localStorage
function loadSets() {
    const saved = localStorage.getItem('flashcardSets');
    if (saved) {
        const userSets = JSON.parse(saved);
        // Filter out bundled sets that might have been saved (shouldn't happen, but just in case)
        sets = sets.filter(s => !s.bundled).concat(userSets);
    }
}

// Save sets to localStorage
function saveSets() {
    localStorage.setItem('flashcardSets', JSON.stringify(sets));
}

// Clear cache and reload bundled sets
function clearCacheAndReload() {
    if (confirm('Clear cache and reload? This will:\n• Clear all localStorage data\n• Force reload of bundled sets with fresh cache-busting\n• Refresh the page')) {
        // Clear localStorage (removes any cached user sets, but they'll need to re-import if needed)
        localStorage.clear();
        
        // Update bundled-sets.js script tag with new timestamp for aggressive cache-busting
        const bundledScript = document.querySelector('script[src*="bundled-sets.js"]');
        if (bundledScript) {
            const timestamp = Date.now();
            bundledScript.src = `bundled-sets.js?v=${timestamp}`;
        }
        
        // Also update app.js script tag
        const appScript = document.querySelector('script[src*="app.js"]');
        if (appScript) {
            const timestamp = Date.now();
            appScript.src = `app.js?v=${timestamp}`;
        }
        
        // Reload page with cache-busting parameter to force fresh script loads
        const timestamp = Date.now();
        const currentUrl = window.location.href.split('?')[0]; // Remove any existing query params
        window.location.href = `${currentUrl}?nocache=${timestamp}`;
    }
}

    // Setup event listeners
    function setupEventListeners() {
        // Drag and drop for questions
        setupQuestionDragAndDrop();
        
        // Mode selector removed - always MC mode for QuizCards
    
    // Main view
    document.getElementById('createSetBtn').addEventListener('click', () => {
        currentSetId = null;
        showView('setEditorView');
        document.getElementById('editorTitle').textContent = 'Create New Set';
        document.getElementById('deleteSetBtn').style.display = 'none';
        document.getElementById('setName').value = '';
        document.getElementById('setYear').value = '';
        document.getElementById('cardsList').innerHTML = '';
        // Reset rounds
        rounds = [];
        const roundsEnabledCheckbox = document.getElementById('roundsEnabled');
        const roundsSection = document.getElementById('roundsSection');
        const roundsList = document.getElementById('roundsList');
        if (roundsEnabledCheckbox) roundsEnabledCheckbox.checked = false;
        if (roundsSection) roundsSection.style.display = 'none';
        if (roundsList) roundsList.innerHTML = '';
        // Reset mode selector - enable it for new sets
        isNewSet = true; // Mark as new set
    });

    document.getElementById('studyBtn').addEventListener('click', () => {
        showView('studySetupView');
        populateSetSelect();
    });

    document.getElementById('importSetBtn').addEventListener('click', () => {
        document.getElementById('importFileInput').click();
    });

    document.getElementById('clearCacheBtn').addEventListener('click', clearCacheAndReload);

    document.getElementById('importFileInput').addEventListener('change', handleImport);

    // Editor view
    document.getElementById('backToMainBtn').addEventListener('click', () => {
        showView('mainView');
    });

    document.getElementById('addCardBtn').addEventListener('click', () => {
        addCardToEditor();
    });
    document.getElementById('saveSetBtn').addEventListener('click', saveSet);
    document.getElementById('deleteSetBtn').addEventListener('click', deleteSet);
    
    // Rounds management
    document.getElementById('roundsEnabled').addEventListener('change', toggleRounds);
    document.getElementById('addRoundBtn').addEventListener('click', addRound);
    
    // Mode selector is handled above in setupEventListeners

    // Study setup
    document.getElementById('backToMainFromSetupBtn').addEventListener('click', () => {
        showView('mainView');
    });

    document.getElementById('selectedSet').addEventListener('change', updateRoundSelect);
    document.getElementById('startStudyBtn').addEventListener('click', startStudy);

    // Study view
    // Card clicking disabled - only MC options can flip cards in QuizCards
    document.getElementById('continueBtn').addEventListener('click', continueMCOption);

    // Results view
    document.getElementById('studyAgainBtn').addEventListener('click', () => {
        showView('studySetupView');
        populateSetSelect();
    });

    document.getElementById('backToMainFromResultsBtn').addEventListener('click', () => {
        showView('mainView');
    });
}

// View management with URL hash support
let isUpdatingHash = false; // Prevent infinite loop

function showView(viewId, updateHash = true) {
    document.querySelectorAll('.view').forEach(view => {
        view.classList.remove('active');
    });
    document.getElementById(viewId).classList.add('active');
    
    // Update navigation elements for gamepad when view changes
    updateGamepadNavigation(viewId);
    
    // Update URL hash based on view (unless we're handling a hash change)
    if (updateHash && !isUpdatingHash) {
        const hashMap = {
            'mainView': '',
            'setEditorView': 'creator',
            'studySetupView': 'study',
            'studyView': 'study',
            'resultsView': 'study'
        };
        
        const hash = hashMap[viewId] || '';
        if (hash) {
            window.location.hash = hash;
        } else {
            // Remove hash for main view
            if (window.location.hash) {
                history.replaceState(null, '', window.location.pathname + window.location.search);
            }
        }
    }
}

// Handle hash changes (for direct navigation/bookmarking)
function handleHashChange() {
    isUpdatingHash = true; // Prevent showView from updating hash during hash change
    
    const hash = window.location.hash.substring(1); // Remove the #
    
    if (hash === 'creator') {
        // Check if we're creating new or editing
        if (currentSetId === null) {
            // Reset mode selector for new set
            const modeSelect = document.getElementById('setModeSelect');
            if (modeSelect) {
                modeSelect.value = 'normal';
                modeSelect.disabled = false;
            }
        } else {
            // Already in editor, just show the view
            showView('setEditorView', false);
        }
    } else if (hash === 'study') {
        // Show study setup if not already in study
        if (!document.getElementById('studyView').classList.contains('active') && 
            !document.getElementById('resultsView').classList.contains('active')) {
            showView('studySetupView', false);
            populateSetSelect();
        }
    } else {
        // Default to main view
        showView('mainView', false);
    }
    
    isUpdatingHash = false;
}

// Render sets list
function renderSets() {
    const setsList = document.getElementById('setsList');
    const bundledSetsList = document.getElementById('bundledSetsList');
    const bundledSetsContainer = document.getElementById('bundledSetsContainer');
    const studyBtn = document.getElementById('studyBtn');

    // Separate bundled sets from user sets
    const bundledSets = sets.filter(set => set.bundled);
    const userSets = sets.filter(set => !set.bundled);

    // Render bundled sets
    if (bundledSets.length > 0) {
        bundledSetsContainer.style.display = 'block';
        bundledSetsList.innerHTML = '';
        bundledSets.forEach((set, originalIndex) => {
            const index = sets.indexOf(set); // Get original index in full sets array
            const setItem = document.createElement('div');
            setItem.className = 'set-item bundled-set';
            
            // Build meta string with cards, rounds, and year
            const metaParts = [];
            metaParts.push(`${set.cards.length} card${set.cards.length !== 1 ? 's' : ''}`);
            if (set.rounds && Array.isArray(set.rounds) && set.rounds.length > 0) {
                metaParts.push(`${set.rounds.length} round${set.rounds.length !== 1 ? 's' : ''}`);
            }
            if (set.year) {
                metaParts.push(`${set.year}`);
            }
            const metaText = metaParts.join(' • ');
            
            setItem.innerHTML = `
                <div class="set-info">
                    <div class="set-name">${escapeHtml(set.name)}</div>
                    <div class="set-meta">${metaText}</div>
                </div>
                <div class="set-actions">
                </div>
            `;
            bundledSetsList.appendChild(setItem);
        });
    } else {
        bundledSetsContainer.style.display = 'none';
    }

    // Render user sets
    if (userSets.length === 0) {
        setsList.innerHTML = '<p class="empty-message">No sets yet. Create your first set to get started!</p>';
    } else {
        setsList.innerHTML = '';
        userSets.forEach((set, originalIndex) => {
            const index = sets.indexOf(set); // Get original index in full sets array
            const setItem = document.createElement('div');
            setItem.className = 'set-item';
            
            // Build meta string with cards, rounds, and year
            const metaParts = [];
            metaParts.push(`${set.cards.length} card${set.cards.length !== 1 ? 's' : ''}`);
            if (set.rounds && Array.isArray(set.rounds) && set.rounds.length > 0) {
                metaParts.push(`${set.rounds.length} round${set.rounds.length !== 1 ? 's' : ''}`);
            }
            if (set.year) {
                metaParts.push(`${set.year}`);
            }
            const metaText = metaParts.join(' • ');
            
            setItem.innerHTML = `
                <div class="set-info" onclick="editSet(${index})">
                    <div class="set-name">${escapeHtml(set.name)}</div>
                    <div class="set-meta">${metaText}</div>
                </div>
                <div class="set-actions">
                    <button class="btn btn-secondary btn-icon" onclick="editSet(${index})">Edit</button>
                    <button class="btn btn-secondary btn-icon" onclick="exportSet(${index})">Export</button>
                    <button class="btn btn-danger btn-icon" onclick="deleteSetFromList(${index})">Delete</button>
                </div>
            `;
            setsList.appendChild(setItem);
        });
    }

    // Enable study button if there are any sets
    studyBtn.disabled = sets.length === 0;
}

// Edit set
function editSet(index) {
    const set = sets[index];
    if (set.bundled) {
        alert('Bundled sets cannot be edited. You can only edit sets you created.');
        return;
    }
    currentSetId = index;
    showView('setEditorView');
    document.getElementById('editorTitle').textContent = 'Edit Set';
    document.getElementById('deleteSetBtn').style.display = 'block';
    document.getElementById('setName').value = set.name;
    
    // Load year if it exists
    const yearInput = document.getElementById('setYear');
    if (set.year) {
        yearInput.value = set.year;
    } else {
        yearInput.value = '';
    }
    
    // Load rounds if they exist
    const roundsEnabledCheckbox = document.getElementById('roundsEnabled');
    const roundsSection = document.getElementById('roundsSection');
    const roundsList = document.getElementById('roundsList');
    
    if (set.rounds && Array.isArray(set.rounds) && set.rounds.length > 0) {
        rounds = [...set.rounds];
        // Sort rounds by number
        rounds.sort((a, b) => a.number - b.number);
        if (roundsEnabledCheckbox) roundsEnabledCheckbox.checked = true;
        if (roundsSection) roundsSection.style.display = 'block';
        renderRounds();
    } else {
        rounds = [];
        if (roundsEnabledCheckbox) roundsEnabledCheckbox.checked = false;
        if (roundsSection) roundsSection.style.display = 'none';
        if (roundsList) roundsList.innerHTML = '';
    }
    
    // Always MC mode for QuizCards
    isNewSet = false; // Existing set
    
    // Clear and load cards - use setTimeout to ensure DOM is ready
    setTimeout(() => {
        const cardsList = document.getElementById('cardsList');
        if (!cardsList) {
            console.error('cardsList element not found');
            return;
        }
        cardsList.innerHTML = '';
        
        if (!set.cards || !Array.isArray(set.cards)) {
            console.warn('Set has no cards or cards is not an array');
            return;
        }
        
        set.cards.forEach((card, cardIndex) => {
            try {
                let questions = card.questions || [{ text: '' }];
                
                // Ensure all questions have order property (migrate old data)
                questions = questions.map((q, index) => {
                    if (typeof q === 'string') {
                        return { text: q, order: index + 1 };
                    }
                    if (!q.order) {
                        return { ...q, order: index + 1 };
                    }
                    return q;
                });
                
                // Sort by order to ensure correct sequence
                questions.sort((a, b) => (a.order || 999) - (b.order || 999));
                
                const hints = card.hints || [];
                // Convert hints array to single string (for backward compatibility)
                const hintText = Array.isArray(hints) && hints.length > 0 ? hints[0] : (typeof hints === 'string' ? hints : '');
                const doNotAccept = card.doNotAccept || '';
                const image = card.image || '';
                const roundId = card.roundId || null;
                // Load MC options if they exist
                const mcOptions = card.mcOptions || [];
                const correctAnswerIndex = card.correctAnswerIndex !== undefined ? card.correctAnswerIndex : null;
                const answer = card.answer || '';
                addCardToEditor(questions, answer, hintText, cardIndex, roundId, doNotAccept, image, mcOptions, correctAnswerIndex);
            } catch (error) {
                console.error(`Error loading card ${cardIndex}:`, error);
            }
        });
    }, 0);
}

// Expand square brackets within text (e.g., GAMETE[S] -> GAMETE, GAMETES)
// [X] means X is optional - generates versions with and without X
function expandSquareBrackets(text) {
    const bracketPattern = /\[([^\]]*)\]/;
    const match = text.match(bracketPattern);
    
    if (!match) {
        return [text]; // No brackets, return as-is
    }
    
    const bracketContent = match[1];
    const beforeBracket = text.substring(0, match.index);
    const afterBracket = text.substring(match.index + match[0].length);
    
    // Two variations: with and without the bracketed content
    const withoutBracket = (beforeBracket + afterBracket).trim();
    const withBracket = (beforeBracket + bracketContent + afterBracket).trim();
    
    // Recursively expand remaining brackets in both variations
    const results = [];
    results.push(...expandSquareBrackets(withoutBracket));
    if (withBracket && withBracket !== withoutBracket) {
        results.push(...expandSquareBrackets(withBracket));
    }
    
    return [...new Set(results)];
}

// Expand (option1/option2) syntax recursively
// Handles nested brackets inside options (e.g., (GAMETE[S]/SEX CELLS))
function expandInterchangeableParts(text) {
    // Find the first (option1/option2/option3) pattern
    const pattern = /\(([^)]+)\)/;
    const match = text.match(pattern);
    
    if (!match) {
        // No parentheses found, but check for square brackets
        return expandSquareBrackets(text);
    }
    
    const options = match[1].split('/').map(opt => opt.trim()).filter(opt => opt.length > 0);
    
    if (options.length === 0) {
        return [text];
    }
    
    // Replace this match with each option and recursively expand
    const beforeMatch = text.substring(0, match.index);
    const afterMatch = text.substring(match.index + match[0].length);
    const results = [];
    
    for (const option of options) {
        // First expand any square brackets in the option itself (e.g., GAMETE[S])
        const optionVariations = expandSquareBrackets(option);
        for (const optionVar of optionVariations) {
            const replaced = beforeMatch + optionVar + afterMatch;
            const expanded = expandInterchangeableParts(replaced);
            results.push(...expanded);
        }
    }
    
    return [...new Set(results)];
}

// Expand answer variations (handles (option1/option2), [optional], and nested patterns)
// Examples:
//   (GAMETE[S]/SEX CELLS) -> GAMETE, GAMETES, SEX CELLS
//   GOLGI [(APPARATUS/BODY/COMPLEX)] -> GOLGI, GOLGI APPARATUS, GOLGI BODY, GOLGI COMPLEX
function expandAnswerVariations(answerText) {
    if (!answerText || !answerText.trim()) return [];
    
    // Find outermost square brackets (not inside parentheses)
    // Process from right to left to maintain string positions
    let processedText = answerText;
    const bracketMatches = [];
    
    // Find all [X] patterns that are not inside parentheses
    for (let i = processedText.length - 1; i >= 0; i--) {
        if (processedText[i] === ']') {
            // Find matching [
            let depth = 0;
            let start = -1;
            for (let j = i - 1; j >= 0; j--) {
                if (processedText[j] === ')') depth++;
                else if (processedText[j] === '(') {
                    depth--;
                    if (depth < 0) break; // Inside parentheses, skip
                } else if (processedText[j] === '[' && depth === 0) {
                    start = j;
                    break;
                }
            }
            
            if (start !== -1) {
                // Check if this bracket pair is inside parentheses
                const beforeStart = processedText.substring(0, start);
                const openParens = (beforeStart.match(/\(/g) || []).length;
                const closeParens = (beforeStart.match(/\)/g) || []).length;
                
                if (openParens === closeParens) {
                    // Not inside parentheses - this is an optional part
                    bracketMatches.push({
                        start: start,
                        end: i + 1,
                        fullMatch: processedText.substring(start, i + 1),
                        content: processedText.substring(start + 1, i)
                    });
                }
            }
        }
    }
    
    // If we have outermost brackets, handle them as optional parts
    if (bracketMatches.length > 0) {
        // Process from right to left
        bracketMatches.sort((a, b) => b.start - a.start);
        
        let variations = [answerText];
        
        for (const match of bracketMatches) {
            const newVariations = [];
            for (const variation of variations) {
                // Version without the optional part (remove brackets)
                const without = variation.substring(0, match.start) + variation.substring(match.end);
                const withoutTrimmed = without.replace(/\s+/g, ' ').trim();
                if (withoutTrimmed) newVariations.push(withoutTrimmed);
                
                // Version with the optional part (replace [X] with X)
                const withPart = variation.substring(0, match.start) + match.content + variation.substring(match.end);
                const withPartTrimmed = withPart.replace(/\s+/g, ' ').trim();
                if (withPartTrimmed) newVariations.push(withPartTrimmed);
            }
            variations = [...new Set(newVariations)];
        }
        
        // Now expand parentheses and any remaining brackets in each variation
        const finalVariations = [];
        for (const variation of variations) {
            finalVariations.push(...expandInterchangeableParts(variation));
        }
        
        return [...new Set(finalVariations.filter(v => v && v.trim()))];
    }
    
    // No outermost brackets, just expand parentheses and nested brackets
    return expandInterchangeableParts(answerText);
}


// Add card to editor
function addCardToEditor(questions = [{ text: '' }], answer = '', hint = '', index = null, roundId = null, doNotAccept = '', image = '', mcOptions = [], correctAnswerIndex = null) {
    const cardsList = document.getElementById('cardsList');
    const cardIndex = index !== null ? index : cardsList.children.length;
    
    // Ensure questions is an array of objects with text property
    if (!Array.isArray(questions) || questions.length === 0) {
        questions = [{ text: '' }];
    }
    
    // Hints is now a single optional string
    const hintText = typeof hint === 'string' ? hint : '';
    
    // DoNotAccept is a single optional string
    const doNotAcceptText = typeof doNotAccept === 'string' ? doNotAccept : '';
    
    // Image is SVG code or data URI
    const imageText = typeof image === 'string' ? image : '';
    
    // Always MC mode for QuizCards
    const mcEnabled = true;
    const mcOptionsArray = Array.isArray(mcOptions) && mcOptions.length > 0 ? mcOptions : ['', ''];
    const correctIndex = correctAnswerIndex !== null && correctAnswerIndex >= 0 && correctAnswerIndex < mcOptionsArray.length ? correctAnswerIndex : null;
    
    const cardItem = document.createElement('div');
    cardItem.className = 'card-item';
    
    // Sort questions by order property (if exists) to ensure correct order
    let sortedQuestions = [...questions].sort((a, b) => {
        const aOrder = (a && a.order) ? a.order : 999;
        const bOrder = (b && b.order) ? b.order : 999;
        return aOrder - bOrder;
    });
    
    // Multiple Choice mode only allows one question - use only the first one
    if (sortedQuestions.length > 1) {
        sortedQuestions = [sortedQuestions[0]];
    }
    
    const questionsHtml = sortedQuestions.map((q, qIndex) => {
        const questionText = typeof q === 'string' ? q : (q.text || '');
        const questionOrder = (q && q.order) ? q.order : (qIndex + 1);
        
        return `
            <div class="question-item" data-question-index="${qIndex}">
                <span style="width: 24px;"></span>
                <div class="question-input-wrapper">
                    <textarea placeholder="Question" class="card-question" data-question-order="${questionOrder}">${escapeHtml(questionText)}</textarea>
                </div>
                <span style="width: 32px;"></span>
            </div>
        `;
    }).join('');
    
    // Build card-level round dropdown if rounds are enabled
    let cardRoundDropdownHtml = '';
    const roundsEnabled = document.getElementById('roundsEnabled').checked;
    if (roundsEnabled && rounds.length > 0) {
        const roundOptions = rounds.map(r => 
            `<option value="${r.id}" ${roundId === r.id ? 'selected' : ''}>Round ${r.number}</option>`
        ).join('');
        cardRoundDropdownHtml = `
            <div class="card-round-select-wrapper">
                <label>Round:</label>
                <select class="card-round-select">
                    <option value="">No Round</option>
                    ${roundOptions}
                </select>
            </div>
        `;
    }
    
    cardItem.innerHTML = `
        <div class="card-item-header">
            <span class="card-item-number">Card ${cardIndex + 1}</span>
            <button class="btn btn-danger btn-small" onclick="removeCard(this)">Remove</button>
        </div>
        <div class="card-item-inputs">
            ${cardRoundDropdownHtml}
            <div class="questions-section">
                <div class="questions-header">
                    <label>Question</label>
                </div>
                <div class="questions-list">
                    ${questionsHtml}
                </div>
            </div>
            <div class="mc-options-section">
                <div class="mc-options-header">
                    <label>Answer Options (at least 2 required, one must be marked correct)</label>
                    <button class="btn btn-secondary btn-tiny add-mc-option-btn" onclick="addMCOption(this)">+ Add Option</button>
                </div>
                <div class="mc-options-list">
                    ${mcOptionsArray.map((option, optIndex) => `
                        <div class="mc-option-item">
                            <input type="radio" name="mc-correct-${cardIndex}" class="mc-correct-radio" value="${optIndex}" ${optIndex === correctIndex ? 'checked' : ''}>
                            <input type="text" placeholder="Option ${optIndex + 1}" class="mc-option-input" value="${escapeHtml(option)}">
                            ${mcOptionsArray.length > 2 ? '<button class="btn btn-danger btn-tiny" onclick="removeMCOption(this)">×</button>' : '<span style="width: 32px;"></span>'}
                        </div>
                    `).join('')}
                </div>
            </div>
            <div class="hints-section">
                <label>Hint (optional, always visible, doesn't affect points)</label>
                <input type="text" placeholder="Hint (e.g., multi-word answer)" class="card-hint" value="${escapeHtml(hintText)}" maxlength="100">
            </div>
            <div class="hints-section">
                <label>DO NOT ACCEPT (optional, always visible, doesn't affect points)</label>
                <input type="text" placeholder="DO NOT ACCEPT (e.g., incorrect answer variation)" class="card-do-not-accept" value="${escapeHtml(doNotAcceptText)}" maxlength="100">
            </div>
            <div class="hints-section">
                <label>Image (optional - SVG, JPG, PNG, or WebP)</label>
                <div class="image-input-wrapper">
                    <textarea placeholder="Paste SVG code or base64 data URI here, or use file upload below" class="card-image-svg" rows="4">${escapeHtml(imageText)}</textarea>
                    <input type="file" accept=".svg,.jpg,.jpeg,.png,.webp,image/svg+xml,image/jpeg,image/png,image/webp" class="card-image-file" style="margin-top: 8px;">
                    <button type="button" class="btn btn-secondary btn-tiny card-image-clear" style="margin-top: 8px;">Clear Image</button>
                </div>
            </div>
        </div>
    `;
    cardsList.appendChild(cardItem);
    
    // Setup Enter key handlers for all question textareas
    const questionTextareas = cardItem.querySelectorAll('.card-question');
    questionTextareas.forEach(textarea => {
        setupQuestionEnterHandler(textarea);
    });
    
    // Setup image file upload handler
    const imageFileInput = cardItem.querySelector('.card-image-file');
    if (imageFileInput) {
        imageFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const svgTextarea = cardItem.querySelector('.card-image-svg');
            if (!svgTextarea) return;
            
            // Check file type
            const isSVG = file.type === 'image/svg+xml' || file.name.toLowerCase().endsWith('.svg');
            const isImage = file.type.startsWith('image/') && (
                file.type === 'image/jpeg' || 
                file.type === 'image/png' || 
                file.type === 'image/webp' ||
                isSVG
            );
            
            if (!isImage) {
                alert('Please select an image file (SVG, JPG, PNG, or WebP).');
                e.target.value = '';
                return;
            }
            
            const reader = new FileReader();
            
            if (isSVG) {
                // SVG: read as text and store as SVG code in JSON (not data URI)
                reader.onload = function(e) {
                    svgTextarea.value = e.target.result; // Raw SVG code like "<svg>...</svg>"
                };
                reader.readAsText(file);
            } else {
                // JPG/PNG/WebP: check dimensions and resize if needed, then convert to base64
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        const MAX_WIDTH = 1280;
                        const MAX_HEIGHT = 720;
                        const MAX_SIZE_KB = 50; // Increased to 50 KB for better compatibility
                        
                        // Function to get size of data URI in KB
                        function getDataURISize(dataURI) {
                            const base64Length = dataURI.length - dataURI.indexOf(',') - 1;
                            const bytes = (base64Length * 3) / 4;
                            return bytes / 1024;
                        }
                        
                        // Function to compress image to fit size limit using binary search
                        function compressImageToSize(canvas, targetSizeKB, useTransparency) {
                            // Format selection:
                            // - PNG for images with transparency (lossless)
                            // - WebP for photos (better compression than JPEG)
                            // - JPEG as fallback if WebP not supported
                            let mimeType = 'image/jpeg';
                            let supportsWebP = false;
                            
                            if (useTransparency) {
                                mimeType = 'image/png';
                            } else {
                                // Test WebP support
                                try {
                                    const testWebP = canvas.toDataURL('image/webp', 0.8);
                                    if (testWebP && testWebP.length > 0 && testWebP.substring(5, 15) === 'image/webp') {
                                        supportsWebP = true;
                                        mimeType = 'image/webp';
                                    }
                                } catch (e) {
                                    // WebP not supported, use JPEG
                                }
                            }
                            
                            // Binary search for optimal quality
                            function findOptimalQuality(canvas, mimeType, targetSizeKB) {
                                let minQuality = 0.1;
                                let maxQuality = 0.9;
                                let bestQuality = 0.5;
                                let bestDataURI = null;
                                let bestSizeKB = Infinity;
                                
                                // Binary search with up to 8 iterations for precision
                                for (let i = 0; i < 8; i++) {
                                    const testQuality = (minQuality + maxQuality) / 2;
                                    const testDataURI = canvas.toDataURL(mimeType, testQuality);
                                    const testSizeKB = getDataURISize(testDataURI);
                                    
                                    if (testSizeKB <= targetSizeKB) {
                                        // This quality works, try higher
                                        if (testSizeKB < bestSizeKB) {
                                            bestQuality = testQuality;
                                            bestDataURI = testDataURI;
                                            bestSizeKB = testSizeKB;
                                        }
                                        minQuality = testQuality;
                                    } else {
                                        // Too large, need lower quality
                                        maxQuality = testQuality;
                                    }
                                }
                                
                                return { 
                                    dataURI: bestDataURI || canvas.toDataURL(mimeType, bestQuality), 
                                    sizeKB: bestSizeKB, 
                                    quality: Math.round(bestQuality * 100) 
                                };
                            }
                            
                            let result = findOptimalQuality(canvas, mimeType, targetSizeKB);
                            let finalCanvas = canvas;
                            
                            // If still too large, reduce dimensions iteratively
                            if (result.sizeKB > targetSizeKB) {
                                let currentCanvas = canvas;
                                const minDimension = useTransparency ? 256 : 320; // PNG needs less resizing
                                let attempts = 0;
                                const maxAttempts = 3; // Limit iteration attempts
                                
                                while (result.sizeKB > targetSizeKB && attempts < maxAttempts) {
                                    attempts++;
                                    // Calculate scale factor to reach target size
                                    // Size is roughly proportional to width * height
                                    const currentSize = result.sizeKB;
                                    const scale = Math.sqrt(targetSizeKB / currentSize) * 0.85; // 15% safety margin
                                    
                                    const newWidth = Math.max(minDimension, Math.round(currentCanvas.width * scale));
                                    const newHeight = Math.max(Math.round(minDimension * 0.75), Math.round(currentCanvas.height * scale));
                                    
                                    // Don't resize if already at minimum
                                    if (newWidth >= currentCanvas.width && newHeight >= currentCanvas.height) {
                                        break;
                                    }
                                    
                                    const tempCanvas = document.createElement('canvas');
                                    tempCanvas.width = newWidth;
                                    tempCanvas.height = newHeight;
                                    const tempCtx = tempCanvas.getContext('2d');
                                    // Better quality for resizing
                                    tempCtx.imageSmoothingEnabled = true;
                                    tempCtx.imageSmoothingQuality = 'high';
                                    tempCtx.drawImage(currentCanvas, 0, 0, newWidth, newHeight);
                                    
                                    // Try again with reduced dimensions
                                    result = findOptimalQuality(tempCanvas, mimeType, targetSizeKB);
                                    currentCanvas = tempCanvas;
                                }
                                
                                finalCanvas = currentCanvas;
                            }
                            
                            return { 
                                ...result, 
                                canvas: finalCanvas, 
                                mimeType: mimeType 
                            };
                        }
                        
                        // Check if image has transparency (for format selection)
                        const hasTransparency = (function() {
                            try {
                                const tempCanvas = document.createElement('canvas');
                                tempCanvas.width = Math.min(img.width, 100);
                                tempCanvas.height = Math.min(img.height, 100);
                                const tempCtx = tempCanvas.getContext('2d');
                                tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
                                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                                const pixels = imageData.data;
                                for (let i = 3; i < pixels.length; i += 4) {
                                    if (pixels[i] < 255) return true;
                                }
                            } catch (e) {
                                // If check fails, assume no transparency
                            }
                            return false;
                        })();
                        
                        // Check if image exceeds 720p
                        let canvas = document.createElement('canvas');
                        let needsResize = false;
                        let originalWidth = img.width;
                        let originalHeight = img.height;
                        
                        if (img.width > MAX_WIDTH || img.height > MAX_HEIGHT) {
                            needsResize = true;
                            let newWidth = img.width;
                            let newHeight = img.height;
                            
                            if (newWidth > MAX_WIDTH) {
                                newHeight = (newHeight * MAX_WIDTH) / newWidth;
                                newWidth = MAX_WIDTH;
                            }
                            
                            if (newHeight > MAX_HEIGHT) {
                                newWidth = (newWidth * MAX_HEIGHT) / newHeight;
                                newHeight = MAX_HEIGHT;
                            }
                            
                            canvas.width = Math.round(newWidth);
                            canvas.height = Math.round(newHeight);
                            const ctx = canvas.getContext('2d');
                            // Better image quality for resizing
                            ctx.imageSmoothingEnabled = true;
                            ctx.imageSmoothingQuality = 'high';
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        } else {
                            canvas.width = img.width;
                            canvas.height = img.height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, img.width, img.height);
                        }
                        
                        // Check size and compress if needed
                        // Select best format: PNG for transparency, WebP for photos, JPEG as fallback
                        let bestFormat = hasTransparency ? 'image/png' : 'image/jpeg';
                        let testDataURI = null;
                        
                        if (hasTransparency) {
                            testDataURI = canvas.toDataURL('image/png');
                        } else {
                            // Test WebP support
                            try {
                                const testWebP = canvas.toDataURL('image/webp', 0.8);
                                if (testWebP && testWebP.length > 0 && testWebP.substring(5, 15) === 'image/webp') {
                                    bestFormat = 'image/webp';
                                    testDataURI = testWebP;
                                }
                            } catch (e) {
                                // WebP not supported
                            }
                        }
                        
                        if (!testDataURI) {
                            testDataURI = canvas.toDataURL(bestFormat, 0.8);
                        }
                        
                        const initialSizeKB = getDataURISize(testDataURI);
                        
                        let messages = [];
                        let dataURI, sizeKB, finalQuality, finalMimeType, finalCanvas = canvas;
                        
                        if (initialSizeKB > MAX_SIZE_KB) {
                            const compressed = compressImageToSize(canvas, MAX_SIZE_KB, hasTransparency);
                            dataURI = compressed.dataURI;
                            sizeKB = compressed.sizeKB;
                            finalQuality = compressed.quality;
                            finalMimeType = compressed.mimeType;
                            finalCanvas = compressed.canvas; // May have been resized
                            
                            if (needsResize || finalCanvas.width !== canvas.width || finalCanvas.height !== canvas.height) {
                                messages.push(`Image was resized to ${finalCanvas.width}x${finalCanvas.height} and compressed to ${sizeKB.toFixed(1)} KB (${finalMimeType}, quality: ${finalQuality}%)`);
                            } else {
                                messages.push(`Image was compressed to ${sizeKB.toFixed(1)} KB (${finalMimeType}, quality: ${finalQuality}%)`);
                            }
                        } else {
                            // Use optimized format
                            finalMimeType = bestFormat;
                            dataURI = testDataURI;
                            sizeKB = initialSizeKB;
                            
                            if (needsResize) {
                                messages.push(`Image was resized from ${originalWidth}x${originalHeight} to ${canvas.width}x${canvas.height} to fit within 720p (1280x720) limit.`);
                            }
                        }
                        
                        // Final check - if still too large, reject
                        if (sizeKB > MAX_SIZE_KB) {
                            alert(`Image is too large (${sizeKB.toFixed(1)} KB). Even after compression, it exceeds the 50 KB limit. Please use a smaller or more compressed image.`);
                            e.target.value = '';
                            return;
                        }
                        
                        svgTextarea.value = dataURI;
                        
                        if (messages.length > 0) {
                            alert(messages.join(' '));
                        }
                    };
                    img.onerror = function() {
                        alert('Error loading image. Please try a different image file.');
                        e.target.value = '';
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
    }
    
    // Setup clear image button
    const clearImageBtn = cardItem.querySelector('.card-image-clear');
    if (clearImageBtn) {
        clearImageBtn.addEventListener('click', function() {
            const svgTextarea = cardItem.querySelector('.card-image-svg');
            const fileInput = cardItem.querySelector('.card-image-file');
            if (svgTextarea) svgTextarea.value = '';
            if (fileInput) fileInput.value = '';
        });
    }
}

// Remove card
function removeCard(button) {
    button.closest('.card-item').remove();
    updateCardNumbers();
    
    // Re-enable mode selector if no cards remain
    const cardsList = document.getElementById('cardsList');
    const modeSelect = document.getElementById('setModeSelect');
    if (cardsList && cardsList.children.length === 0 && isNewSet && modeSelect) {
        modeSelect.disabled = false;
    }
}

// Update card numbers
function updateCardNumbers() {
    const cards = document.querySelectorAll('.card-item');
    cards.forEach((card, index) => {
        card.querySelector('.card-item-number').textContent = `Card ${index + 1}`;
    });
}

// Handle Enter key on question textarea to move to next question
function setupQuestionEnterHandler(textarea) {
    textarea.addEventListener('keydown', (e) => {
        // If Enter is pressed without Shift, move to next question
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            
            const questionsList = textarea.closest('.questions-list');
            const questionItems = Array.from(questionsList.querySelectorAll('.question-item'));
            const currentItem = textarea.closest('.question-item');
            const currentIndex = questionItems.indexOf(currentItem);
            
            // If there's a next question, focus it
            if (currentIndex < questionItems.length - 1) {
                const nextTextarea = questionItems[currentIndex + 1].querySelector('.card-question');
                if (nextTextarea) {
                    nextTextarea.focus();
                }
            } else {
                // If this is the last question, create a new one
                const addButton = textarea.closest('.questions-section').querySelector('.questions-header button');
                if (addButton) {
                    addQuestion(addButton);
                    // Focus the newly created question
                    const newQuestionsList = textarea.closest('.questions-list');
                    const newQuestionItems = Array.from(newQuestionsList.querySelectorAll('.question-item'));
                    const newTextarea = newQuestionItems[newQuestionItems.length - 1].querySelector('.card-question');
                    if (newTextarea) {
                        newTextarea.focus();
                    }
                }
            }
        }
    });
}

// Add question to a card
function addQuestion(button) {
    // Not used in QuizCards - MC mode only allows one question
    alert('Quiz cards can only have one question.');
    return;
    
    const questionsList = button.closest('.questions-section').querySelector('.questions-list');
    const questionItems = questionsList.querySelectorAll('.question-item');
    const questionCount = questionItems.length;
    
    // Find the highest order number to assign next
    let maxOrder = 0;
    questionItems.forEach(item => {
        const textarea = item.querySelector('.card-question');
        if (textarea) {
            const order = parseInt(textarea.getAttribute('data-question-order')) || 0;
            if (order > maxOrder) maxOrder = order;
        }
    });
    const nextOrder = maxOrder + 1;
    
    const questionItem = document.createElement('div');
    questionItem.className = 'question-item';
    questionItem.setAttribute('data-question-index', questionCount.toString());
    questionItem.innerHTML = `
        <div class="question-drag-handle" draggable="true">⋮⋮</div>
        <div class="question-input-wrapper">
            <textarea placeholder="Question ${nextOrder}" class="card-question" data-question-order="${nextOrder}"></textarea>
        </div>
        <button class="btn btn-danger btn-tiny" onclick="removeQuestion(this)">×</button>
    `;
    questionsList.appendChild(questionItem);
    
    // Setup Enter key handler for the new question
    const newTextarea = questionItem.querySelector('.card-question');
    if (newTextarea) {
        setupQuestionEnterHandler(newTextarea);
    }
}

// Remove question from a card
function removeQuestion(button) {
    const questionsList = button.closest('.questions-list');
    const cardItem = button.closest('.card-item');
    const modeSelect = document.getElementById('setModeSelect');
    const mcEnabled = modeSelect ? (modeSelect.value === 'multipleChoice') : false;
    
    // Multiple Choice mode only allows one question, so don't allow removal
    if (mcEnabled && questionsList.children.length === 1) {
        alert('Multiple Choice cards must have exactly one question.');
        return;
    }
    
    if (questionsList.children.length > 1) {
        button.closest('.question-item').remove();
    } else {
        alert('Each card must have at least one question');
    }
}

// Add MC option to a card
function addMCOption(button) {
    const cardItem = button.closest('.card-item');
    const mcOptionsList = cardItem.querySelector('.mc-options-list');
    const cardIndex = Array.from(document.querySelectorAll('.card-item')).indexOf(cardItem);
    const optionCount = mcOptionsList.children.length;
    
    const optionItem = document.createElement('div');
    optionItem.className = 'mc-option-item';
    optionItem.innerHTML = `
        <input type="radio" name="mc-correct-${cardIndex}" class="mc-correct-radio" value="${optionCount}">
        <input type="text" placeholder="Option ${optionCount + 1}" class="mc-option-input">
        <button class="btn btn-danger btn-tiny" onclick="removeMCOption(this)">×</button>
    `;
    mcOptionsList.appendChild(optionItem);
    
    // Focus the new input
    const newInput = optionItem.querySelector('.mc-option-input');
    if (newInput) newInput.focus();
}

// Remove MC option from a card
function removeMCOption(button) {
    const mcOptionsList = button.closest('.mc-options-list');
    const optionItem = button.closest('.mc-option-item');
    const radioButton = optionItem.querySelector('.mc-correct-radio');
    const wasChecked = radioButton && radioButton.checked;
    
    if (mcOptionsList.children.length > 2) {
        optionItem.remove();
        
        // If the removed option was checked, check the first option
        if (wasChecked) {
            const firstRadio = mcOptionsList.querySelector('.mc-correct-radio');
            if (firstRadio) firstRadio.checked = true;
        }
        
        // Renumber options
        const cardItem = button.closest('.card-item');
        const cardIndex = Array.from(document.querySelectorAll('.card-item')).indexOf(cardItem);
        const options = mcOptionsList.querySelectorAll('.mc-option-item');
        options.forEach((item, index) => {
            const radio = item.querySelector('.mc-correct-radio');
            const input = item.querySelector('.mc-option-input');
            if (radio) {
                radio.name = `mc-correct-${cardIndex}`;
                radio.value = index;
            }
            if (input) {
                input.placeholder = `Option ${index + 1}`;
            }
        });
    } else {
        alert('Each card must have at least two answer options');
    }
}

// Toggle Multiple Choice mode - now handled by dropdown, this function is kept for compatibility but does nothing
function toggleMultipleChoice() {
    // Mode is now controlled by dropdown, this function is deprecated
}

// Toggle rounds mode
function toggleRounds() {
    const enabled = document.getElementById('roundsEnabled').checked;
    const roundsSection = document.getElementById('roundsSection');
    
    if (enabled) {
        roundsSection.style.display = 'block';
        // Don't auto-add rounds - user must click "Add Round" manually
        renderRounds();
        updateAllCardRoundDropdowns();
    } else {
        // Check if any cards are assigned to rounds
        const cardItems = document.querySelectorAll('.card-item');
        let hasAssignedRounds = false;
        cardItems.forEach(cardItem => {
            const roundSelect = cardItem.querySelector('.card-round-select');
            if (roundSelect && roundSelect.value) {
                hasAssignedRounds = true;
            }
        });
        
        if (hasAssignedRounds) {
            alert('Cannot disable rounds. Please remove round assignments from all cards first.');
            const roundsEnabledCheckbox = document.getElementById('roundsEnabled');
            if (roundsEnabledCheckbox) roundsEnabledCheckbox.checked = true;
            return;
        }
        
        roundsSection.style.display = 'none';
    }
}

// Add a new round
function addRound() {
    // Get existing round numbers to check for duplicates
    const existingNumbers = rounds.map(r => r.number);
    
    // Find the next available number starting from 1
    let suggestedNumber = 1;
    while (existingNumbers.includes(suggestedNumber)) {
        suggestedNumber++;
    }
    
    // Prompt for round number with suggested default
    const input = prompt(`Enter round number:`, suggestedNumber);
    
    if (input === null) {
        // User cancelled
        return;
    }
    
    const roundNumber = parseInt(input, 10);
    
    // Validate input
    if (isNaN(roundNumber) || roundNumber < 1) {
        alert('Please enter a valid positive number');
        return;
    }
    
    // Check for duplicates
    if (existingNumbers.includes(roundNumber)) {
        alert(`Round ${roundNumber} already exists. Please choose a different number.`);
        return;
    }
    
    const roundId = 'round_' + Date.now();
    rounds.push({ id: roundId, number: roundNumber });
    
    // Sort rounds by number for display
    rounds.sort((a, b) => a.number - b.number);
    
    renderRounds();
    updateAllCardRoundDropdowns();
}

// Remove a round
function removeRound(roundId) {
    if (rounds.length <= 1) {
        alert('You must have at least one round');
        return;
    }
    
    // Remove round from array
    rounds = rounds.filter(r => r.id !== roundId);
    
    // Clear round selection from all cards
    document.querySelectorAll('.card-round-select').forEach(select => {
        if (select.value === roundId) {
            select.value = '';
        }
    });
    
    renderRounds();
    updateAllCardRoundDropdowns();
}

// Render rounds list
function renderRounds() {
    const roundsList = document.getElementById('roundsList');
    roundsList.innerHTML = '';
    
    rounds.forEach(round => {
        const roundItem = document.createElement('div');
        roundItem.className = 'round-item';
        roundItem.innerHTML = `
            <span>Round ${round.number}</span>
            <button class="btn btn-secondary btn-tiny" onclick="editRoundNumber('${round.id}')" title="Edit round number">Edit</button>
            <button class="btn btn-danger btn-tiny" onclick="removeRoundById('${round.id}')">×</button>
        `;
        roundsList.appendChild(roundItem);
    });
}

// Edit round number
function editRoundNumber(roundId) {
    const round = rounds.find(r => r.id === roundId);
    if (!round) return;
    
    // Get existing round numbers (excluding current round)
    const existingNumbers = rounds.filter(r => r.id !== roundId).map(r => r.number);
    
    // Prompt for new round number
    const input = prompt(`Enter new number for Round ${round.number}:`, round.number);
    
    if (input === null) {
        // User cancelled
        return;
    }
    
    const roundNumber = parseInt(input, 10);
    
    // Validate input
    if (isNaN(roundNumber) || roundNumber < 1) {
        alert('Please enter a valid positive number');
        return;
    }
    
    // Check for duplicates
    if (existingNumbers.includes(roundNumber)) {
        alert(`Round ${roundNumber} already exists. Please choose a different number.`);
        return;
    }
    
    // Update round number
    round.number = roundNumber;
    
    // Sort rounds by number for display
    rounds.sort((a, b) => a.number - b.number);
    
    renderRounds();
    updateAllCardRoundDropdowns();
}

// Remove round by ID (for onclick handlers)
function removeRoundById(roundId) {
    removeRound(roundId);
}

// Update all card round dropdowns
function updateAllCardRoundDropdowns() {
    const roundsEnabled = document.getElementById('roundsEnabled').checked;
    
    // Update card-level dropdowns
    document.querySelectorAll('.card-round-select').forEach(select => {
        const currentValue = select.value;
        const roundOptions = rounds.map(r => 
            `<option value="${r.id}" ${currentValue === r.id ? 'selected' : ''}>Round ${r.number}</option>`
        ).join('');
        select.innerHTML = '<option value="">No Round</option>' + roundOptions;
    });
    
    // If rounds were just enabled, add dropdowns to existing cards
    if (roundsEnabled && rounds.length > 0) {
        document.querySelectorAll('.card-item').forEach(cardItem => {
            // Check if card already has round dropdown
            if (!cardItem.querySelector('.card-round-select-wrapper')) {
                const cardInputs = cardItem.querySelector('.card-item-inputs');
                const roundOptions = rounds.map(r => 
                    `<option value="${r.id}">Round ${r.number}</option>`
                ).join('');
                const roundDropdownHtml = `
                    <div class="card-round-select-wrapper">
                        <label>Round:</label>
                        <select class="card-round-select">
                            <option value="">No Round</option>
                            ${roundOptions}
                        </select>
                    </div>
                `;
                cardInputs.insertAdjacentHTML('afterbegin', roundDropdownHtml);
            }
        });
    } else if (!roundsEnabled) {
        // Remove all round dropdowns when rounds are disabled
        document.querySelectorAll('.card-round-select-wrapper').forEach(el => el.remove());
    }
}

// Save set
function saveSet() {
    const name = document.getElementById('setName').value.trim();
    if (!name) {
        alert('Please enter a set name');
        return;
    }

    const yearInput = document.getElementById('setYear');
    const year = yearInput.value.trim() ? parseInt(yearInput.value, 10) : null;
    if (year && (isNaN(year) || year < 1900 || year > 2100)) {
        alert('Please enter a valid year between 1900 and 2100');
        return;
    }

    const cards = [];
    const cardItems = document.querySelectorAll('.card-item');
    const roundsEnabled = document.getElementById('roundsEnabled').checked;
    
    cardItems.forEach(cardItem => {
        const questionInputs = cardItem.querySelectorAll('.card-question');
        const questions = [];
        
        questionInputs.forEach((input) => {
            const text = input.value.trim();
            if (text.length > 0) {
                // Get order from data attribute, or assign based on position
                const order = parseInt(input.getAttribute('data-question-order')) || (questions.length + 1);
                questions.push({ text, order });
            }
        });
        
        // Sort questions by order before saving
        questions.sort((a, b) => a.order - b.order);
        // Renumber to keep orders contiguous (prevents weird Q1/Q3 jumps later)
        questions.forEach((q, idx) => { q.order = idx + 1; });
        
        // Get hint (single optional field)
        const hintInput = cardItem.querySelector('.card-hint');
        const hint = hintInput ? hintInput.value.trim() : '';
        
        // Get doNotAccept (single optional field)
        const doNotAcceptInput = cardItem.querySelector('.card-do-not-accept');
        const doNotAccept = doNotAcceptInput ? doNotAcceptInput.value.trim() : '';
        
        // Get image (SVG code)
        const imageTextarea = cardItem.querySelector('.card-image-svg');
        const image = imageTextarea ? imageTextarea.value.trim() : '';
        
        // Get card-level round ID if rounds are enabled
        let cardRoundId = null;
        if (roundsEnabled) {
            const cardRoundSelect = cardItem.querySelector('.card-round-select');
            if (cardRoundSelect && cardRoundSelect.value) {
                cardRoundId = cardRoundSelect.value;
            }
        }
        
        // Always MC mode for QuizCards
        const mcOptionInputs = cardItem.querySelectorAll('.mc-option-input');
        const mcOptions = [];
        let correctAnswerIndex = null;
        
        mcOptionInputs.forEach((input, index) => {
            const optionText = input.value.trim();
            if (optionText) {
                mcOptions.push(optionText);
                // Check if this option is marked as correct
                const radioButton = cardItem.querySelector(`input[name^="mc-correct"][value="${index}"]`);
                if (radioButton && radioButton.checked) {
                    correctAnswerIndex = mcOptions.length - 1; // Index in filtered array
                }
            }
        });
        
        if (questions.length > 0 && mcOptions.length >= 2) {
            if (correctAnswerIndex === null) {
                alert(`Card ${cards.length + 1}: Please mark one answer option as correct.`);
                return;
            }
            const cardData = { questions, mcOptions, correctAnswerIndex };
            if (hint) {
                cardData.hints = [hint];
            }
            if (doNotAccept) {
                cardData.doNotAccept = doNotAccept;
            }
            if (image) {
                cardData.image = image;
            }
            if (cardRoundId) {
                cardData.roundId = cardRoundId;
            }
            cards.push(cardData);
        } else if (questions.length > 0 && mcOptions.length < 2) {
            alert(`Card ${cards.length + 1}: Cards must have at least 2 answer options.`);
            return;
        }
    });

    if (cards.length === 0) {
        alert('Please add at least one card with at least one question and 2+ answer options');
        return;
    }

    const setData = { name, cards, multipleChoice: true }; // Always MC mode
    
    // Save year if provided
    if (year) {
        setData.year = year;
    }
    
    // Save rounds if enabled and has rounds
    if (roundsEnabled && rounds.length > 0) {
        setData.rounds = rounds;
    }
    
    // Preserve bundled status if editing a bundled set
    if (currentSetId !== null) {
        const existingSet = sets[currentSetId];
        if (existingSet && existingSet.bundled) {
            setData.bundled = true;
            setData.bundledFileName = existingSet.bundledFileName;
        }
        sets[currentSetId] = setData;
    } else {
        sets.push(setData);
    }

    saveSets();
    renderSets();
    showView('mainView');
}

// Delete set from list
function deleteSetFromList(index) {
    const set = sets[index];
    if (set.bundled) {
        alert('Bundled sets cannot be deleted. You can only delete sets you created.');
        return;
    }
    if (confirm('Are you sure you want to delete this set?')) {
        sets.splice(index, 1);
        saveSets();
        renderSets();
    }
}

// Delete set from editor
function deleteSet() {
    if (currentSetId !== null) {
        const set = sets[currentSetId];
        if (set.bundled) {
            alert('Bundled sets cannot be deleted. You can only delete sets you created.');
            return;
        }
        if (confirm('Are you sure you want to delete this set?')) {
            sets.splice(currentSetId, 1);
            saveSets();
            renderSets();
            showView('mainView');
        }
    }
}

// Export set
function exportSet(index) {
    const set = sets[index];
    if (set.bundled) {
        alert('Bundled sets cannot be exported. You can only export sets you created.');
        return;
    }
    const exportData = {
        name: set.name,
        cards: set.cards,
        exportedAt: new Date().toISOString()
    };
    
    // Include year if it exists
    if (set.year) {
        exportData.year = set.year;
    }
    
    // Include rounds if they exist
    if (set.rounds && Array.isArray(set.rounds) && set.rounds.length > 0) {
        exportData.rounds = set.rounds;
    }
    
    // Include multiple choice mode if it exists
    if (set.multipleChoice) {
        exportData.multipleChoice = true;
    }
    
    const dataStr = JSON.stringify(exportData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${set.name.replace(/[^a-z0-9]/gi, '_')}.json`;
    link.click();
    URL.revokeObjectURL(url);
}

// Populate set select
function populateSetSelect() {
    const select = document.getElementById('selectedSet');
    select.innerHTML = '<option value="">Select a set...</option>';
    
    sets.forEach((set, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = `${set.name} (${set.cards.length} cards)`;
        select.appendChild(option);
    });
    
    updateRoundSelect();
}

// Update round select based on selected set
function updateRoundSelect() {
    const select = document.getElementById('selectedSet');
    const roundSelect = document.getElementById('selectedRound');
    const roundSelectGroup = document.getElementById('roundSelectGroup');
    
    if (select.value === '') {
        roundSelectGroup.style.display = 'none';
        roundSelect.innerHTML = '<option value="">All Rounds</option>';
        return;
    }
    
    const setIndex = parseInt(select.value);
    const set = sets[setIndex];
    
    // Check if set has rounds
    if (set.rounds && Array.isArray(set.rounds) && set.rounds.length > 0) {
        roundSelectGroup.style.display = 'block';
        roundSelect.innerHTML = '<option value="">All Rounds</option>';
        
        // Sort rounds by number
        const sortedRounds = [...set.rounds].sort((a, b) => a.number - b.number);
        
        sortedRounds.forEach(round => {
            const option = document.createElement('option');
            option.value = round.id;
            option.textContent = `Round ${round.number}`;
            roundSelect.appendChild(option);
        });
    } else {
        roundSelectGroup.style.display = 'none';
        roundSelect.innerHTML = '<option value="">All Rounds</option>';
    }
}

// Start study
function startStudy() {
    const select = document.getElementById('selectedSet');
    const roundSelect = document.getElementById('selectedRound');
    
    if (select.value === '') {
        alert('Please select a set');
        return;
    }
    
    const setIndex = parseInt(select.value);
    const set = sets[setIndex];
    
    // Progressive mode not used in QuizCards (MC mode only)
    progressiveMode = false;
    
    // Filter cards by round if a specific round is selected
    let cardsToStudy = [...set.cards];
    const selectedRoundId = roundSelect.value;
    
    if (selectedRoundId) {
        // Filter to only cards in the selected round
        cardsToStudy = cardsToStudy.filter(card => card.roundId === selectedRoundId);
        
        if (cardsToStudy.length === 0) {
            alert('No cards found in the selected round');
        return;
        }
    }
    
    // Shuffle all cards (or filtered cards)
    studyCards = cardsToStudy.sort(() => Math.random() - 0.5);
    currentCardIndex = 0;
    currentQuestionIndex = 0;
    shownQuestions = []; // Reset shown questions
    currentCardQuestions = []; // Reset cached questions
    currentCardQuestionsForCardIndex = -1;
    studyResults = { correct: 0, wrong: 0, points: 0, cards: [] };
    selectedMCOption = null; // Reset selected option
    
    showView('studyView');
    updateStudyCard();
}

// Update study card
function updateStudyCard(showHint = false) {
    if (currentCardIndex >= studyCards.length) {
        showResults();
        return;
    }
    
    const card = studyCards[currentCardIndex];
    // Get questions (assume current format: array of objects with text property)
    const questions = (Array.isArray(card.questions) && card.questions.length) ? card.questions : [{ text: '' }];
    
    // MC mode always uses first question (only one question per card)
    const questionObj = questions[0] || { text: '' };
    const questionText = questionObj.text || questionObj || '';
    document.getElementById('questionText').textContent = questionText;
    
    // Display hints (only on front/question side)
    const hints = card.hints || [];
    const hintsFront = document.getElementById('hintsFront');
    const hintsBack = document.getElementById('hintsBack');
    
    if (hints.length > 0) {
        const hintsText = hints.join(' • ');
        if (hintsFront) hintsFront.textContent = hintsText;
    } else {
        if (hintsFront) hintsFront.textContent = '';
    }
    // Always clear hints on back (answer side)
        if (hintsBack) hintsBack.textContent = '';
    
    // Display doNotAccept (only on back/answer side)
    const doNotAccept = card.doNotAccept || '';
    const doNotAcceptFront = document.getElementById('doNotAcceptFront');
    const doNotAcceptBack = document.getElementById('doNotAcceptBack');
    
    // Always clear doNotAccept on front (question side)
    if (doNotAcceptFront) doNotAcceptFront.textContent = '';
    
    if (doNotAccept) {
        const doNotAcceptText = `DO NOT ACCEPT: ${doNotAccept}`;
        if (doNotAcceptBack) doNotAcceptBack.textContent = doNotAcceptText;
    } else {
        if (doNotAcceptBack) doNotAcceptBack.textContent = '';
    }
    
    // Display image (SVG, JPG, PNG, WebP)
    const image = card.image || '';
    const cardImageFront = document.getElementById('cardImageFront');
    const cardImageBack = document.getElementById('cardImageBack');
    const cardFront = document.querySelector('.card-front');
    const cardBack = document.querySelector('.card-back');
    
    if (image && image.trim()) {
        // Check if it's inline SVG, base64 data URI, or SVG code
        let imageHtml = '';
        const trimmedImage = image.trim();
        
        if (trimmedImage.startsWith('<svg')) {
            // Inline SVG code - use directly (don't escape HTML tags)
            imageHtml = trimmedImage;
        } else if (trimmedImage.startsWith('data:image/')) {
            // Base64 data URI (SVG, JPG, PNG, WebP) - use img tag
            imageHtml = `<img src="${escapeHtml(trimmedImage)}" alt="Card image" class="card-image-content">`;
        } else {
            // Try to treat as SVG code
            imageHtml = trimmedImage;
        }
        
        if (cardImageFront) {
            cardImageFront.innerHTML = imageHtml;
            cardImageFront.style.display = 'flex';
        }
        if (cardImageBack) {
            cardImageBack.innerHTML = imageHtml;
            cardImageBack.style.display = 'flex';
        }
        
        // Add class to enable side-by-side layout
        if (cardFront) cardFront.classList.add('has-image');
        if (cardBack) cardBack.classList.add('has-image');
    } else {
        if (cardImageFront) {
            cardImageFront.innerHTML = '';
            cardImageFront.style.display = 'none';
        }
        if (cardImageBack) {
            cardImageBack.innerHTML = '';
            cardImageBack.style.display = 'none';
        }
        
        // Remove class to use normal layout
        if (cardFront) cardFront.classList.remove('has-image');
        if (cardBack) cardBack.classList.remove('has-image');
    }
    
    // No progressive mode in QuizCards
    
    // Always MC mode for QuizCards
    const flashcard = document.getElementById('quizcard') || document.getElementById('flashcard');
    const isFlipped = flashcard.classList.contains('flipped');
    
    // Add MC mode class to flashcard
    flashcard.classList.add('mc-mode');
    
    // MC Mode: Show options on front, result on back
        const mcOptions = card.mcOptions || [];
        const correctAnswerIndex = card.correctAnswerIndex !== undefined ? card.correctAnswerIndex : null;
        const mcOptionsContainer = document.getElementById('mcOptionsContainerExternal') || document.getElementById('mcOptionsContainer');
        
        if (!isFlipped) {
            // Front: Show question and MC options
            selectedMCOption = null; // Reset selection
            
            // Ensure question text container is visible and question is set
            const cardTextContent = document.querySelector('.card-front .card-text-content');
            if (cardTextContent) {
                cardTextContent.style.display = 'flex';
                cardTextContent.style.visibility = 'visible';
            }
            const questionTextElement = document.getElementById('questionText');
            if (questionTextElement) {
                questionTextElement.style.display = 'block';
                questionTextElement.style.visibility = 'visible';
                // If question text is empty, try to get it from the card
                if (!questionTextElement.textContent || questionTextElement.textContent.trim() === '') {
                    const questions = card.questions || [];
                    if (questions.length > 0) {
                        const firstQuestion = questions[0];
                        const questionText = (typeof firstQuestion === 'string') ? firstQuestion : (firstQuestion.text || '');
                        if (questionText) {
                            questionTextElement.textContent = questionText;
                        }
                    }
                }
            }
            
            if (mcOptions.length >= 2) {
                // Calculate optimal button width based on longest option
                const longestOption = mcOptions.reduce((a, b) => {
                    const aLen = typeof a === 'string' ? a.length : String(a).length;
                    const bLen = typeof b === 'string' ? b.length : String(b).length;
                    return aLen > bLen ? a : b;
                }, '');
                const longestLength = typeof longestOption === 'string' ? longestOption.length : String(longestOption).length;
                // Estimate width: roughly 8-10px per character, with padding
                const estimatedWidth = Math.max(200, Math.min(400, longestLength * 9 + 40));
                
                let mcHtml = '<div class="mc-options-study">';
                mcOptions.forEach((option, index) => {
                    mcHtml += `<button class="mc-option-btn" onclick="selectMCOption(${index})" data-option-index="${index}">${escapeHtml(option)}</button>`;
                });
                mcHtml += '</div>';
                
                // Set a CSS variable for button width
                const cardFront = document.querySelector('.card-front');
                if (cardFront) {
                    cardFront.style.setProperty('--mc-btn-width', `${estimatedWidth}px`);
                }
                
                // Use external MC options container (below the card)
                let container = document.getElementById('mcOptionsContainer') || document.getElementById('mcOptionsContainerExternal');
                if (container) {
                    container.innerHTML = mcHtml;
                    container.style.display = 'block';
                }
                
                // After rendering, measure all buttons and set them to the width of the widest
                setTimeout(() => {
                    const buttons = container.querySelectorAll('.mc-option-btn');
                    if (buttons.length > 0) {
                        let maxWidth = 200; // minimum width
                        // First pass: measure natural width of each button
                        buttons.forEach(btn => {
                            // Save original width style
                            const originalWidth = btn.style.width;
                            // Set to auto to measure natural content width
                            btn.style.width = 'auto';
                            btn.style.maxWidth = 'none';
                            const width = btn.getBoundingClientRect().width;
                            if (width > maxWidth) {
                                maxWidth = width;
                            }
                            // Restore original
                            btn.style.width = originalWidth;
                        });
                        // Add some padding for safety
                        maxWidth = Math.ceil(maxWidth) + 10;
                        // Second pass: set all buttons to the max width
                        buttons.forEach(btn => {
                            btn.style.width = `${maxWidth}px`;
                            btn.style.maxWidth = '100%'; // But still respect container width
                        });
                    }
                }, 10);
            }
            
            // Flip button not used in MC mode
        } else {
            // Back: Show if correct/wrong and correct answer
            const isCorrect = selectedMCOption !== null && selectedMCOption === correctAnswerIndex;
            const resultText = isCorrect ? '✓ Correct!' : '✗ Incorrect';
            const resultClass = isCorrect ? 'mc-result-correct' : 'mc-result-incorrect';
            
            let answerHtml = `<div class="mc-result ${resultClass}">${resultText}</div>`;
            if (correctAnswerIndex !== null && correctAnswerIndex < mcOptions.length) {
                answerHtml += `<div class="mc-correct-answer">Correct Answer: ${escapeHtml(mcOptions[correctAnswerIndex])}</div>`;
            }
            
            document.getElementById('answerText').innerHTML = answerHtml;
            document.getElementById('acceptedAnswersList').innerHTML = '';
            
            // Hide MC options container on back
            const container = document.getElementById('mcOptionsContainer');
            if (container) {
                container.style.display = 'none';
                container.innerHTML = ''; // Clear options
            }
        }
    
    // Always ensure card starts face-down (not flipped) on new card
    if (!isFlipped) {
        flashcard.classList.remove('flipped');
        selectedMCOption = null; // Reset selection on new card
    }
    
    // Show/hide buttons based on flip state (always MC mode)
    if (isFlipped) {
        const continueBtn = document.getElementById('continueBtn');
        if (continueBtn) continueBtn.style.display = 'block';
    } else {
        const continueBtn = document.getElementById('continueBtn');
        if (continueBtn) continueBtn.style.display = 'none';
    }
    
    // Update gamepad navigation when buttons change visibility
    if (getCurrentViewId() === 'studyView' && gamepadState.connected) {
        updateGamepadNavigation('studyView');
    }
    
    const progress = ((currentCardIndex + 1) / studyCards.length) * 100;
    document.getElementById('progressText').textContent = `Question ${currentCardIndex + 1} of ${studyCards.length}`;
    document.getElementById('progressFill').style.width = `${progress}%`;
}

// Select MC option (triggers flip)
function selectMCOption(optionIndex) {
    if (studyMultipleChoiceMode && currentCardIndex < studyCards.length) {
        selectedMCOption = optionIndex;
        flipCard();
    }
}

// Flip card
function flipCard() {
    const flashcard = document.getElementById('quizcard') || document.getElementById('flashcard');
    flashcard.classList.add('flipped');
    
    // Hint button removed - not used in QuizCards
    
    // Update card display (important for MC mode to show result)
    updateStudyCard();
    
    // Update gamepad navigation for study view when buttons change
    if (getCurrentViewId() === 'studyView' && gamepadState.connected) {
        updateGamepadNavigation('studyView');
    }
}

// Continue from multiple choice (auto-determines correctness)
function continueMCOption() {
    if (!studyMultipleChoiceMode || currentCardIndex >= studyCards.length) {
        return;
    }
    
    const card = studyCards[currentCardIndex];
    const correctAnswerIndex = card.correctAnswerIndex !== undefined ? card.correctAnswerIndex : null;
    const isCorrect = (selectedMCOption !== null && selectedMCOption === correctAnswerIndex);
    
    markAnswer(isCorrect);
}

// Mark answer
function markAnswer(isCorrect) {
    const card = studyCards[currentCardIndex];
    
    // Always MC mode - determine correctness from selected option
    const correctAnswerIndex = card.correctAnswerIndex !== undefined ? card.correctAnswerIndex : null;
    isCorrect = (selectedMCOption !== null && selectedMCOption === correctAnswerIndex);
    
    // Get the question that was shown
    const questionElement = document.getElementById('questionText');
    const questionText = questionElement ? questionElement.textContent : '';
    
    // Store card result
    studyResults.cards.push({
        card: card,
        result: isCorrect ? 'correct' : 'wrong',
        question: questionText
    });
    
    // Simple correct/wrong tracking
    if (isCorrect) {
        studyResults.correct++;
        studyResults.points += 1;
    } else {
        studyResults.wrong++;
    }
    
    // Move to next card
    currentCardIndex++;
    currentQuestionIndex = 0;
    shownQuestions = [];
    currentCardQuestions = [];
    currentCardQuestionsForCardIndex = -1;
    
    // Slide out current card and slide in next card (always face-down)
    const flashcard = document.getElementById('quizcard') || document.getElementById('flashcard');
    
    // Ensure card is face-down before sliding out
    flashcard.classList.remove('flipped');
    flashcard.classList.add('slide-out');
    
    // Wait for card to slide completely off screen before showing next card
    setTimeout(() => {
        // Update to show the next card (progressive mode will start with Question 1)
        updateStudyCard();
        
        // Update gamepad navigation when card state changes
        if (getCurrentViewId() === 'studyView' && gamepadState.connected) {
            updateGamepadNavigation('studyView');
        }
        
        // Slide in the new card (already face-down from updateStudyCard)
        flashcard.classList.remove('slide-out');
        flashcard.classList.add('slide-in');
        
        // Remove slide-in class after animation completes
        setTimeout(() => {
            flashcard.classList.remove('slide-in');
        }, 600);
    }, 600);
}

// Ask for next question (add more to the card)
function askForHint() {
    // Not used in QuizCards - no progressive mode
}


// Show results
function showResults() {
    const total = studyResults.correct + studyResults.wrong;
    const accuracy = total > 0 ? Math.round((studyResults.correct / total) * 100) : 0;
    
    document.getElementById('totalCards').textContent = total;
    document.getElementById('correctCards').textContent = studyResults.correct;
    document.getElementById('wrongCards').textContent = studyResults.wrong;
    document.getElementById('accuracyPercent').textContent = `${accuracy}%`;
    
    // Points not shown in QuizCards
    
    // Display each card with its result
    const cardsList = document.getElementById('cardsResultsList');
    if (cardsList) {
        cardsList.innerHTML = '';
        studyResults.cards.forEach((cardResult, index) => {
            const cardItem = document.createElement('div');
            cardItem.className = `card-result-item ${cardResult.result}`;
            const resultIcon = cardResult.result === 'correct' ? '✓' : '✗';
            const resultClass = cardResult.result === 'correct' ? 'correct' : 'wrong';
            
            // Get answer - always MC mode
            const card = cardResult.card;
            const mcOptions = card.mcOptions || [];
            const correctAnswerIndex = card.correctAnswerIndex !== undefined ? card.correctAnswerIndex : null;
            let answerText = 'N/A';
            if (correctAnswerIndex !== null && correctAnswerIndex < mcOptions.length) {
                answerText = mcOptions[correctAnswerIndex];
            }
            
            cardItem.innerHTML = `
                <div class="card-result-header">
                    <span class="card-result-number">Question ${index + 1}</span>
                    <span class="card-result-badge ${resultClass}">${resultIcon} ${cardResult.result === 'correct' ? 'Correct' : 'Wrong'}</span>
                </div>
                <div class="card-result-content">
                    <div class="card-result-question">
                        <strong>Question:</strong> ${escapeHtml(cardResult.question)}
                    </div>
                    <div class="card-result-answer">
                        <strong>Correct Answer:</strong> ${escapeHtml(answerText)}
                    </div>
                </div>
            `;
            cardsList.appendChild(cardItem);
        });
    }
    
    showView('resultsView');
}

// Utility: Escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Import set
function handleImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const importData = JSON.parse(e.target.result);
            
            if (!importData.name || !importData.cards || !Array.isArray(importData.cards)) {
                alert('Invalid file format');
                return;
            }

            const setData = {
                name: importData.name,
                cards: importData.cards
            };
            
            // Include year if it exists
            if (importData.year) {
                setData.year = importData.year;
            }
            
            // Include rounds if they exist
            if (importData.rounds && Array.isArray(importData.rounds) && importData.rounds.length > 0) {
                setData.rounds = importData.rounds;
            }
            
            // Include multiple choice mode if it exists
            if (importData.multipleChoice) {
                setData.multipleChoice = true;
            }
            
            sets.push(setData);
            saveSets();
            renderSets();
            alert('Set imported successfully!');
        } catch (error) {
            alert('Error importing file. Please make sure it is a valid JSON file.');
        }
    };
    reader.readAsText(file);
    event.target.value = ''; // Reset input
}


// Setup drag and drop for question reordering
function setupQuestionDragAndDrop() {
    let draggedElement = null;
    let placeholder = null;
    let draggedQuestionItem = null;

    document.addEventListener('dragstart', (e) => {
        // Only allow dragging from the drag handle
        if (e.target.classList.contains('question-drag-handle')) {
            draggedQuestionItem = e.target.closest('.question-item');
            if (draggedQuestionItem) {
                draggedElement = draggedQuestionItem;
            e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/html', draggedQuestionItem.outerHTML);

            // Add dragging class for visual feedback
                draggedQuestionItem.classList.add('dragging');

            // Create placeholder
            placeholder = document.createElement('div');
            placeholder.className = 'question-item question-placeholder';
                placeholder.innerHTML = '<div class="question-drag-handle" draggable="true">⋮⋮</div><div class="question-input-wrapper"><div class="placeholder-text">Drop here</div></div>';

                draggedQuestionItem.style.opacity = '0.5';
            }
        }
    });

    document.addEventListener('dragend', (e) => {
        if (draggedQuestionItem) {
            draggedQuestionItem.classList.remove('dragging');
            draggedQuestionItem.style.opacity = '';
            draggedQuestionItem = null;
            draggedElement = null;

            if (placeholder && placeholder.parentNode) {
                placeholder.remove();
                placeholder = null;
            }
        }
    });

    document.addEventListener('dragover', (e) => {
        if (draggedQuestionItem) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            const target = e.target.closest('.question-item');
            if (target && target !== draggedQuestionItem && target !== placeholder) {
                const rect = target.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;

                if (placeholder && placeholder.parentNode) {
                    placeholder.remove();
                }

                if (e.clientY < midpoint) {
                    // Insert before target
                    target.parentNode.insertBefore(placeholder, target);
                } else {
                    // Insert after target
                    target.parentNode.insertBefore(placeholder, target.nextSibling);
                }
            }
        }
    });

    document.addEventListener('drop', (e) => {
        e.preventDefault();

        if (draggedQuestionItem && placeholder && placeholder.parentNode) {
            // Replace placeholder with dragged element
            placeholder.parentNode.replaceChild(draggedQuestionItem, placeholder);

            // Update question indices and order properties
            updateQuestionIndices(draggedQuestionItem.closest('.questions-list'));

            placeholder = null;
            draggedQuestionItem = null;
            draggedElement = null;
        }
    });
}

// Update question indices and data attributes after reordering
function updateQuestionIndices(questionsList) {
    const questionItems = questionsList.querySelectorAll('.question-item:not(.question-placeholder)');

    questionItems.forEach((item, index) => {
        item.setAttribute('data-question-index', index.toString());

        const textarea = item.querySelector('.card-question');
        if (textarea) {
            textarea.setAttribute('data-question-order', (index + 1).toString());
            textarea.placeholder = `Question ${index + 1}`;
        }
    });
}

// ============================================================================
// Gamepad Support
// ============================================================================

// Setup gamepad support
function setupGamepadSupport() {
    // Listen for gamepad connect/disconnect events
    window.addEventListener('gamepadconnected', (e) => {
        console.log('Gamepad connected:', e.gamepad.id);
        gamepadState.connected = true;
        gamepadState.gamepad = e.gamepad;
        gamepadState.previousButtons = new Array(e.gamepad.buttons.length).fill(false);
        gamepadState.previousAxes = new Array(e.gamepad.axes.length).fill(0);
        updateGamepadNavigation(getCurrentViewId());
        startGamepadPolling();
    });

    window.addEventListener('gamepaddisconnected', (e) => {
        console.log('Gamepad disconnected:', e.gamepad.id);
        gamepadState.connected = false;
        gamepadState.gamepad = null;
        clearGamepadFocus();
    });

    // Check for already connected gamepads
    if (navigator.getGamepads) {
        const gamepads = navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i]) {
                gamepadState.connected = true;
                gamepadState.gamepad = gamepads[i];
                gamepadState.previousButtons = new Array(gamepads[i].buttons.length).fill(false);
                gamepadState.previousAxes = new Array(gamepads[i].axes.length).fill(0);
                updateGamepadNavigation(getCurrentViewId());
                startGamepadPolling();
                break;
            }
        }
    }
}

// Get current active view ID
function getCurrentViewId() {
    const activeView = document.querySelector('.view.active');
    return activeView ? activeView.id : 'mainView';
}

// Start gamepad polling loop
function startGamepadPolling() {
    if (!gamepadState.connected) return;

    function pollGamepad() {
        if (!gamepadState.connected) return;

        // Get fresh gamepad state
        const gamepads = navigator.getGamepads();
        const gamepad = gamepads[0]; // Use first connected gamepad
        
        if (!gamepad) {
            gamepadState.connected = false;
            gamepadState.gamepad = null;
            clearGamepadFocus();
            return;
        }

        gamepadState.gamepad = gamepad;
        handleGamepadInput(gamepad);
        
        requestAnimationFrame(pollGamepad);
    }
    
    pollGamepad();
}

// Handle gamepad input
function handleGamepadInput(gamepad) {
    const now = Date.now();
    const activeViewId = getCurrentViewId();
    
    // Handle buttons (pressed = 1.0, not pressed = 0.0)
    for (let i = 0; i < gamepad.buttons.length; i++) {
        const pressed = gamepad.buttons[i].pressed || gamepad.buttons[i].value > 0.5;
        const wasPressed = gamepadState.previousButtons[i] || false;
        
        if (pressed && !wasPressed && (now - gamepadState.lastButtonPress) > gamepadState.buttonDebounceDelay) {
            handleButtonPress(i, activeViewId);
            gamepadState.lastButtonPress = now;
        }
        
        gamepadState.previousButtons[i] = pressed;
    }
    
    // Handle D-pad / Left stick for navigation
    handleDpadNavigation(gamepad, activeViewId);
}

// Handle button press
function handleButtonPress(buttonIndex, viewId) {
    // Xbox/Standard mapping:
    // 0 = A (Cross on PS)
    // 1 = B (Circle on PS)
    // 2 = X (Square on PS)
    // 3 = Y (Triangle on PS)
    // 8 = Back/Select
    // 9 = Start
    
    switch (viewId) {
        case 'studyView':
            handleStudyViewButtons(buttonIndex);
            break;
        case 'resultsView':
            handleResultsViewButtons(buttonIndex);
            break;
        case 'mainView':
            handleMainViewButtons(buttonIndex);
            break;
        case 'studySetupView':
            handleSetupViewButtons(buttonIndex);
            break;
        case 'setEditorView':
            handleEditorViewButtons(buttonIndex);
            break;
    }
}

// Handle buttons in study view
function handleStudyViewButtons(buttonIndex) {
    const flashcard = document.getElementById('quizcard') || document.getElementById('flashcard');
    const isFlipped = flashcard && flashcard.classList.contains('flipped');
    
    switch (buttonIndex) {
        case 0: // A / X button - Activate focused element or default action
            // Check if we have a focused element (navigation mode)
            const focused = document.querySelector('.gamepad-focused');
            if (focused) {
                // If there's a focused element, activate it
                activateFocusedElement();
            } else {
                // Fallback to default behavior
                if (isFlipped) {
                    markAnswer(true); // Right answer
                } else {
                    flipCard(); // Flip to see answer
                }
            }
            break;
        case 1: // B / Circle button - Mark wrong (when flipped) or activate focused
            const focusedElement = document.querySelector('.gamepad-focused');
            if (focusedElement) {
                // If focused on wrong button, activate it
                if (focusedElement.id === 'wrongBtn') {
                    markAnswer(false);
                }
            } else if (isFlipped) {
                markAnswer(false); // Wrong answer
            }
            break;
        case 3: // Y / Triangle button - Add next question (progressive mode) or activate focused
            // Progressive mode not used in QuizCards
            break;
        case 8: // Back button - Go back to main
            showView('mainView');
            break;
    }
}

// Handle buttons in results view
function handleResultsViewButtons(buttonIndex) {
    switch (buttonIndex) {
        case 0: // A / X button - Study again
            document.getElementById('studyAgainBtn').click();
            break;
        case 1: // B / Circle button - Back to main
        case 8: // Back button
            document.getElementById('backToMainFromResultsBtn').click();
            break;
    }
}

// Handle buttons in main view
function handleMainViewButtons(buttonIndex) {
    switch (buttonIndex) {
        case 0: // A / X button - Activate focused element
            activateFocusedElement();
            break;
    }
}

// Handle buttons in setup view
function handleSetupViewButtons(buttonIndex) {
    switch (buttonIndex) {
        case 0: // A / X button - Activate focused element
            activateFocusedElement();
            break;
        case 1: // B / Circle button - Back
        case 8: // Back button
            document.getElementById('backToMainFromSetupBtn').click();
            break;
    }
}

// Activate the currently focused element (handles buttons, inputs, selects, checkboxes)
function activateFocusedElement() {
    const focused = document.querySelector('.gamepad-focused');
    if (focused) {
        if (focused.tagName === 'BUTTON') {
            focused.click();
        } else if (focused.tagName === 'INPUT') {
            if (focused.type === 'checkbox') {
                focused.checked = !focused.checked;
                focused.dispatchEvent(new Event('change', { bubbles: true }));
            } else {
                focused.focus();
                // For number inputs, don't select all text, just focus
                if (focused.type === 'number') {
                    focused.focus();
                } else {
                    focused.select();
                }
            }
        } else if (focused.tagName === 'SELECT') {
            // For SELECT dropdowns, cycle through options when A is pressed
            // Don't try to open the dropdown - just cycle through options
            if (focused.options.length > 0) {
                const currentIndex = focused.selectedIndex >= 0 ? focused.selectedIndex : 0;
                const nextIndex = (currentIndex + 1) % focused.options.length;
                focused.selectedIndex = nextIndex;
                focused.dispatchEvent(new Event('change', { bubbles: true }));
                // Also trigger input event for compatibility
                focused.dispatchEvent(new Event('input', { bubbles: true }));
            }
        } else {
            // Default: click if it's clickable
            focused.click();
        }
    } else if (gamepadState.navigationElements.length > 0) {
        // Fallback: activate element at current navigation index
        const element = gamepadState.navigationElements[gamepadState.navigationIndex];
        if (element) {
            if (element.tagName === 'BUTTON') {
                element.click();
            } else if (element.tagName === 'INPUT' && element.type === 'checkbox') {
                element.checked = !element.checked;
                element.dispatchEvent(new Event('change', { bubbles: true }));
            } else {
                element.focus();
            }
        }
    }
}

// Handle buttons in editor view
function handleEditorViewButtons(buttonIndex) {
    switch (buttonIndex) {
        case 1: // B / Circle button - Back
        case 8: // Back button
            document.getElementById('backToMainBtn').click();
            break;
        case 0: // A / X button - Save (if focused)
            const focused = document.querySelector('.gamepad-focused');
            if (focused && focused.id === 'saveSetBtn') {
                focused.click();
            }
            break;
    }
}

// Handle D-pad / Left stick navigation
function handleDpadNavigation(gamepad, viewId) {
    // D-pad: axes 6 and 7 (if available), or use button mapping
    // Left stick: axes 0 (horizontal) and 1 (vertical)
    
    const deadzone = 0.5; // Deadzone for analog sticks
    let horizontal = 0;
    let vertical = 0;
    
    // Check left stick first
    if (gamepad.axes.length >= 2) {
        horizontal = Math.abs(gamepad.axes[0]) > deadzone ? gamepad.axes[0] : 0;
        vertical = Math.abs(gamepad.axes[1]) > deadzone ? gamepad.axes[1] : 0;
    }
    
    // Check D-pad buttons (if stick isn't active)
    if (Math.abs(horizontal) < 0.1 && Math.abs(vertical) < 0.1 && gamepad.buttons.length >= 15) {
        // D-pad is usually buttons 12-15 on standard controllers
        // 12 = D-pad up, 13 = D-pad down, 14 = D-pad left, 15 = D-pad right
        if (gamepad.buttons[12] && gamepad.buttons[12].pressed) vertical = -1;
        if (gamepad.buttons[13] && gamepad.buttons[13].pressed) vertical = 1;
        if (gamepad.buttons[14] && gamepad.buttons[14].pressed) horizontal = -1;
        if (gamepad.buttons[15] && gamepad.buttons[15].pressed) horizontal = 1;
    }
    
    // Handle navigation based on view
    if (Math.abs(horizontal) > 0.1 || Math.abs(vertical) > 0.1) {
        const now = Date.now();
        if (now - gamepadState.lastButtonPress > 300) { // Throttle navigation
            if (viewId === 'mainView' || viewId === 'studySetupView' || viewId === 'resultsView' || viewId === 'setEditorView' || viewId === 'studyView') {
                // Normal navigation
                navigateWithDpad(vertical, horizontal);
            }
            gamepadState.lastButtonPress = now;
        }
    }
}

// Navigate with D-pad
function navigateWithDpad(vertical, horizontal) {
    if (gamepadState.navigationElements.length === 0) return;
    
    const currentIndex = gamepadState.navigationIndex;
    const currentElement = gamepadState.navigationElements[currentIndex];
    
    // If horizontal input is present, always navigate (allows navigating away from inputs/selects)
    const hasHorizontalInput = Math.abs(horizontal) > 0.1;
    
    // If focused element is a number input, handle up/down as increment/decrement (unless navigating horizontally)
    if (!hasHorizontalInput && currentElement && currentElement.tagName === 'INPUT' && currentElement.type === 'number') {
        if (vertical < -0.5) { // Up - increment
            const step = parseFloat(currentElement.step) || 1;
            const max = currentElement.max ? parseFloat(currentElement.max) : Infinity;
            const currentValue = parseFloat(currentElement.value) || 0;
            const newValue = Math.min(max, currentValue + step);
            currentElement.value = newValue;
            currentElement.dispatchEvent(new Event('input', { bubbles: true }));
            currentElement.dispatchEvent(new Event('change', { bubbles: true }));
            return; // Don't navigate away
        } else if (vertical > 0.5) { // Down - decrement
            const step = parseFloat(currentElement.step) || 1;
            const min = currentElement.min ? parseFloat(currentElement.min) : -Infinity;
            const currentValue = parseFloat(currentElement.value) || 0;
            const newValue = Math.max(min, currentValue - step);
            currentElement.value = newValue;
            currentElement.dispatchEvent(new Event('input', { bubbles: true }));
            currentElement.dispatchEvent(new Event('change', { bubbles: true }));
            return; // Don't navigate away
        }
    }
    
    // SELECT dropdowns - don't auto-cycle on D-pad, just navigate past them
    // User needs to press A to open/interact with the dropdown
    
    // Default navigation behavior - navigate between elements
    let newIndex = currentIndex;
    
    // For form layouts, use single-column navigation
    // Vertical navigation (up/down) - navigate between elements
    if (vertical < -0.5) { // Up
        newIndex = Math.max(0, currentIndex - 1);
    } else if (vertical > 0.5) { // Down
        newIndex = Math.min(gamepadState.navigationElements.length - 1, currentIndex + 1);
    }
    
    // Horizontal navigation (left/right) - for single column, left goes up, right goes down
    // This allows navigating away from number inputs and selects
    if (horizontal < -0.5) { // Left - navigate up
        newIndex = Math.max(0, currentIndex - 1);
    } else if (horizontal > 0.5) { // Right - navigate down
        newIndex = Math.min(gamepadState.navigationElements.length - 1, currentIndex + 1);
    }
    
    if (newIndex !== currentIndex) {
        setGamepadFocus(newIndex);
    }
}

// Update gamepad navigation elements based on current view
function updateGamepadNavigation(viewId) {
    gamepadState.navigationElements = [];
    gamepadState.navigationIndex = 0;
    clearGamepadFocus();
    
    switch (viewId) {
        case 'mainView':
            // Main action buttons
            const mainButtons = ['createSetBtn', 'studyBtn', 'importSetBtn'];
            mainButtons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn && !btn.disabled) {
                    gamepadState.navigationElements.push(btn);
                }
            });
            break;
            
        case 'studySetupView':
            // Setup elements in order (top to bottom)
            const setupElements = [
                'backToMainFromSetupBtn',
                'selectedSet',
                'cardCount',
                'progressiveMode',
                'startStudyBtn'
            ];
            setupElements.forEach(id => {
                const element = document.getElementById(id);
                if (element && (element.tagName === 'BUTTON' ? !element.disabled : true)) {
                    gamepadState.navigationElements.push(element);
                }
            });
            break;
            
        case 'resultsView':
            // Results buttons
            const resultsButtons = ['studyAgainBtn', 'backToMainFromResultsBtn'];
            resultsButtons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    gamepadState.navigationElements.push(btn);
                }
            });
            break;
            
        case 'setEditorView':
            // Editor buttons
            const editorButtons = ['saveSetBtn', 'backToMainBtn'];
            editorButtons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    gamepadState.navigationElements.push(btn);
                }
            });
            break;
            
        case 'studyView':
            // Study view buttons - dynamically based on what's visible
            const flipBtn = document.getElementById('flipCardBtn');
            const wrongBtn = document.getElementById('wrongBtn');
            const rightBtn = document.getElementById('rightBtn');
            const continueBtn = document.getElementById('continueBtn');
            // Check if card is flipped
            const flashcard = document.getElementById('quizcard') || document.getElementById('flashcard');
            const isFlipped = flashcard && flashcard.classList.contains('flipped');
            
            if (isFlipped) {
                // When flipped, show continue button (always MC mode)
                if (continueBtn && continueBtn.offsetParent !== null) {
                    gamepadState.navigationElements.push(continueBtn);
                }
            } else {
                // When not flipped, MC options are shown (handled separately)
                // No flip button or hint button in QuizCards
            }
            break;
    }
    
    // Set initial focus
    if (gamepadState.navigationElements.length > 0) {
        setGamepadFocus(0);
    }
}

// Set gamepad focus on an element
function setGamepadFocus(index) {
    if (index < 0 || index >= gamepadState.navigationElements.length) return;
    
    clearGamepadFocus();
    gamepadState.navigationIndex = index;
    const element = gamepadState.navigationElements[index];
    if (element) {
        element.classList.add('gamepad-focused');
        // Scroll element into view if needed
        element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
}

// Clear gamepad focus
function clearGamepadFocus() {
    document.querySelectorAll('.gamepad-focused').forEach(el => {
        el.classList.remove('gamepad-focused');
    });
}

// Make functions available globally for onclick handlers
window.editSet = editSet;
window.deleteSetFromList = deleteSetFromList;
window.exportSet = exportSet;
window.removeCard = removeCard;
window.addQuestion = addQuestion;
window.removeQuestion = removeQuestion;
window.removeRoundById = removeRoundById;
window.editRoundNumber = editRoundNumber;

